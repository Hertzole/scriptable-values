using System;
using System.Text;
using Microsoft.CodeAnalysis.Text;
using SourceProductionContext = Microsoft.CodeAnalysis.SourceProductionContext;
using SymbolDisplayFormat = Microsoft.CodeAnalysis.SymbolDisplayFormat;

namespace Hertzole.ScriptableValues.Generator;

partial class ScriptableCallbackGenerator
{
	private static ReadOnlySpan<char> ScriptableValueChanging
	{
		get { return "ScriptableValueCallbackChanging".AsSpan(); }
	}

	private static ReadOnlySpan<char> ScriptableValueChanged
	{
		get { return "ScriptableValueCallbackChanged".AsSpan(); }
	}

	private static void GenerateCode(SourceProductionContext context, (HierarchyInfo Key, EquatableArray<CallbackData> Elements) item)
	{
		CodeWriter writer = new CodeWriter();

		try
		{
			writer.AppendLine("// <auto-generated/>");
			writer.AppendLine("#nullable enable");

			bool hasNamespace = !string.IsNullOrEmpty(item.Key.Namespace);

			if (hasNamespace)
			{
				writer.Append("namespace ");
				writer.AppendLine(item.Key.Namespace!);
				writer.AppendLine("{");
				writer.Indent++;
			}

			//TODO: Support other types?
			writer.Append("partial class ");
			writer.AppendLine(item.Key.MetadataName);
			writer.AppendLine("{");
			writer.Indent++;

			WriteElements(writer, in context, in item.Key, in item.Elements);

			writer.Indent--;
			writer.Append("}");

			if (hasNamespace)
			{
				writer.AppendLine();
				writer.Indent--;
				writer.Append("}");
			}
		}
		catch (Exception e)
		{
			writer.Clear();
			writer.AppendLine("// Error generating code:");
			writer.AppendLine("// " + e.Message);
			writer.AppendLine("// " + e.StackTrace);
		}

		context.AddSource($"{item.Key.FilenameHint}.g.cs", SourceText.From(writer.ToString(), Encoding.UTF8));
	}

	private static void WriteElements(CodeWriter writer,
		in SourceProductionContext context,
		in HierarchyInfo hierarchy,
		in EquatableArray<CallbackData> elements)
	{
		WriteSubscribedBitMask(writer, in context, in elements);
		writer.AppendLine();

		WriteCachedFields(writer, in context, in hierarchy, in elements);
		writer.AppendLine();

		WriteSubscribeAndUnsubscribeMethods(in writer, in context, in hierarchy, in elements);
		writer.AppendLine();

		WriteCallbacksMethods(in writer, in context, in elements);
	}

	private static void WriteSubscribedBitMask(CodeWriter writer, in SourceProductionContext context, in EquatableArray<CallbackData> data)
	{
		context.CancellationToken.ThrowIfCancellationRequested();

		using (writer.WithIndent(0))
		{
			writer.AppendLine("#if UNITY_EDITOR");
		}

		writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
		WriteGeneratedCodeAttribute(writer);
		using (writer.WithIndent(0))
		{
			writer.AppendLine("#endif // UNITY_EDITOR");
		}

		int actualCount = 0;
		for (int i = 0; i < data.Length; i++)
		{
			context.CancellationToken.ThrowIfCancellationRequested();

			if (data[i].CallbackType == CallbackType.Value)
			{
				// If it's a value and has both pre and post invoke, we need to count it as two.
				if ((data[i].Flags & CallbackFlags.PreAndPostInvoke) == CallbackFlags.PreAndPostInvoke)
				{
					actualCount++;
				}
			}

			actualCount++;
		}

		writer.Append("private enum SubscribedCallbacksMask : ");
		if (actualCount < 8)
		{
			writer.AppendLine("byte");
		}
		else if (actualCount < 16)
		{
			writer.AppendLine("ushort");
		}
		else if (actualCount < 32)
		{
			writer.AppendLine("uint");
		}
		else
		{
			writer.AppendLine("ulong");
		}

		writer.AppendLine("{");
		writer.Indent++;

		writer.Append("None = 0");

		int actualIndex = 0;
		for (int i = 0; i < data.Length; i++)
		{
			context.CancellationToken.ThrowIfCancellationRequested();

			writer.AppendLine(",");
			writer.Append(data[i].Name);
			if (data[i].CallbackType == CallbackType.Value)
			{
				// If it's a value and has both pre and post invoke, we need to count it as two.
				if ((data[i].Flags & CallbackFlags.PreAndPostInvoke) == CallbackFlags.PreAndPostInvoke)
				{
					writer.Append("Changing = 1 << ");
					writer.Append(actualIndex);
					actualIndex++;
					writer.AppendLine(",");
					writer.Append(data[i].Name);
					writer.Append("Changed");
				}
				else
				{
					writer.Append((data[i].Flags & CallbackFlags.PostInvoke) != 0 ? "Changed" : "Changing");
				}
			}

			writer.Append(" = 1 << ");
			writer.Append(actualIndex);
			actualIndex++;
		}

		writer.AppendLine();

		writer.Indent--;
		writer.AppendLine("}");

		writer.AppendLine();
		using (writer.WithIndent(0))
		{
			writer.AppendLine("#if UNITY_EDITOR");
		}

		writer.AppendLine("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
		WriteGeneratedCodeAttribute(writer);
		using (writer.WithIndent(0))
		{
			writer.AppendLine("#endif // UNITY_EDITOR");
		}

		writer.AppendLine("private SubscribedCallbacksMask subscribedCallbacks = SubscribedCallbacksMask.None;");
	}

	private static void WriteCachedFields(CodeWriter writer,
		in SourceProductionContext context,
		in HierarchyInfo hierarchy,
		in EquatableArray<CallbackData> data)
	{
		for (int i = 0; i < data.Length; i++)
		{
			context.CancellationToken.ThrowIfCancellationRequested();

			WriteField(writer, in hierarchy, in data[i]);
		}

		return;

		static void WriteField(CodeWriter writer, in HierarchyInfo hierarchy, in CallbackData data)
		{
			switch (data.CallbackType)
			{
				case CallbackType.Value:
					WriteValueField(writer, in hierarchy, in data);
					break;
			}
		}
	}

	private static void WriteSubscribeAndUnsubscribeMethods(in CodeWriter writer,
		in SourceProductionContext context,
		in HierarchyInfo hierarchy,
		in EquatableArray<CallbackData> elements)
	{
		context.CancellationToken.ThrowIfCancellationRequested();

		WriteGeneratedCodeAttribute(in writer, true);
		writer.AppendExcludeFromCodeCoverageAttribute();
		writer.AppendLine("private void SubscribeToScriptableCallbacks()");
		writer.AppendLine("{");
		writer.Indent++;

		for (int i = 0; i < elements.Length; i++)
		{
			context.CancellationToken.ThrowIfCancellationRequested();

			CallbackFlags overrideFlags = CallbackFlags.None;

			if ((elements[i].Flags & CallbackFlags.PreAndPostInvoke) == CallbackFlags.PreAndPostInvoke)
			{
				WriteIfCheck(in writer, in hierarchy, in elements[i], true, CallbackFlags.PreInvoke);

				overrideFlags = CallbackFlags.PostInvoke;
			}

			WriteIfCheck(in writer, in hierarchy, in elements[i], true, overrideFlags);
		}

		writer.Indent--;
		writer.AppendLine("}");
		writer.AppendLine();

		WriteGeneratedCodeAttribute(in writer, true);
		writer.AppendExcludeFromCodeCoverageAttribute();
		writer.AppendLine("private void UnsubscribeFromScriptableCallbacks()");
		writer.AppendLine("{");
		writer.Indent++;

		for (int i = 0; i < elements.Length; i++)
		{
			context.CancellationToken.ThrowIfCancellationRequested();

			CallbackFlags overrideFlags = CallbackFlags.None;

			if ((elements[i].Flags & CallbackFlags.PreAndPostInvoke) == CallbackFlags.PreAndPostInvoke)
			{
				WriteIfCheck(in writer, in hierarchy, in elements[i], false, CallbackFlags.PreInvoke);

				overrideFlags = CallbackFlags.PostInvoke;
			}

			WriteIfCheck(in writer, in hierarchy, in elements[i], false, overrideFlags);
		}

		writer.Indent--;
		writer.AppendLine("}");
		return;

		static void WriteIfCheck(in CodeWriter writer,
			in HierarchyInfo hierarchy,
			in CallbackData data,
			bool subscribe,
			CallbackFlags overrideFlags = CallbackFlags.None)
		{
			if (overrideFlags == CallbackFlags.None)
			{
				overrideFlags = data.Flags;
			}

			ReadOnlySpan<char> flagsSuffix = data.GetFlagsSuffix(overrideFlags);

			writer.Append("if ((subscribedCallbacks & SubscribedCallbacksMask.");
			writer.Append(data.Name);
			writer.Append(flagsSuffix);
			writer.Append(") ");
			writer.Append(subscribe ? "== 0" : "!= 0");
			writer.AppendLine(")");
			writer.AppendLine("{");
			writer.Indent++;

			writer.Append(data.Name);

			if (subscribe)
			{
				switch (data.CallbackType)
				{
					case CallbackType.Value:
						writer.Append(".RegisterValue");
						writer.Append(data.GetFlagsSuffix(overrideFlags));
						writer.Append("Listener(");
						writer.Append(data.Name);
						writer.Append((overrideFlags & CallbackFlags.PreInvoke) != 0 ? ScriptableValueChanging : ScriptableValueChanged);
						break;
					case CallbackType.Event:
						break;
					case CallbackType.Collection:
						break;
					case CallbackType.Pool:
						break;
					default:
						throw new ArgumentOutOfRangeException();
				}

				writer.AppendLine(", this);");
				writer.Append("subscribedCallbacks |= SubscribedCallbacksMask.");
			}
			else
			{
				switch (data.CallbackType)
				{
					case CallbackType.Value:
						writer.Append(".UnregisterValue");
						writer.Append(data.GetFlagsSuffix(overrideFlags));
						writer.Append("Listener<");
						writer.Append(hierarchy.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
						writer.Append(">(");
						writer.Append(data.Name);
						writer.Append((overrideFlags & CallbackFlags.PreInvoke) != 0 ? ScriptableValueChanging : ScriptableValueChanged);
						break;
					case CallbackType.Event:
						break;
					case CallbackType.Collection:
						break;
					case CallbackType.Pool:
						break;
					default:
						throw new ArgumentOutOfRangeException();
				}

				writer.AppendLine(");");
				writer.Append("subscribedCallbacks &= ~SubscribedCallbacksMask.");
			}

			writer.Append(data.Name);
			writer.Append(flagsSuffix);
			writer.AppendLine(";");

			writer.Indent--;
			writer.AppendLine("}");
		}
	}

	private static void WriteCallbacksMethods(in CodeWriter writer, in SourceProductionContext context, in EquatableArray<CallbackData> elements)
	{
		for (int i = 0; i < elements.Length; i++)
		{
			if (i > 0)
			{
				writer.AppendLine();
			}

			context.CancellationToken.ThrowIfCancellationRequested();

			switch (elements[i].CallbackType)
			{
				case CallbackType.Value:
					WriteValueCallbackMethod(in writer, in elements[i]);
					break;
				case CallbackType.Event:
					break;
				case CallbackType.Collection:
					break;
				case CallbackType.Pool:
					break;
				default:
					throw new ArgumentOutOfRangeException();
			}
		}

		static void WriteValueCallbackMethod(in CodeWriter writer, in CallbackData data)
		{
			ArrayBuilder<string> parameterTypes = new ArrayBuilder<string>(2);
			ArrayBuilder<string> parameterNames = new ArrayBuilder<string>(2);

			try
			{
				string genericType = data.GenericType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

				parameterTypes.Add(genericType);
				parameterNames.Add("oldValue");

				parameterTypes.Add(genericType);
				parameterNames.Add("newValue");

				if ((data.Flags & CallbackFlags.PreAndPostInvoke) == CallbackFlags.PreAndPostInvoke)
				{
					WriteCallbackMethod(in writer, data.GetCallbackName(CallbackFlags.PreInvoke), parameterTypes.AsSpan(), parameterNames.AsSpan());
					writer.AppendLine();
					WriteCallbackMethod(in writer, data.GetCallbackName(CallbackFlags.PostInvoke), parameterTypes.AsSpan(), parameterNames.AsSpan());
				}
				else
				{
					WriteCallbackMethod(in writer, data.GetCallbackName(), parameterTypes.AsSpan(), parameterNames.AsSpan());
				}
			}
			finally
			{
				parameterTypes.Dispose();
				parameterNames.Dispose();
			}
		}

		static void WriteCallbackMethod(in CodeWriter writer,
			in ReadOnlySpan<char> name,
			in ReadOnlySpan<string> parameterTypes,
			in ReadOnlySpan<string> parameterNames)
		{
			writer.Append("partial void ");
			writer.Append(name);
			writer.Append("(");

			for (int i = 0; i < parameterTypes.Length; i++)
			{
				if (i > 0)
				{
					writer.Append(", ");
				}

				writer.Append(parameterTypes[i]);
				writer.Append(" ");
				writer.Append(parameterNames[i]);
			}

			writer.AppendLine(");");
		}
	}
}