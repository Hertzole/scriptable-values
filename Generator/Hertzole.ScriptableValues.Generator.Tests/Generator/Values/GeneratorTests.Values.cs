using System;
using System.Text;
using NUnit.Framework;

namespace Hertzole.ScriptableValues.Generator.Tests;

partial class GeneratorTests
{
	public static readonly string[] valueArguments =
	[
		"ValueCallbackType.Changing",
		"ValueCallbackType.Changed"
	];

	[Test]
	public void Value_Field_NoArguments_EmitsChanged([Values] ContainingType containingType)
	{
		string source = /*lang=cs*/$@"using System;
using Hertzole.ScriptableValues;

namespace My.Namespace
{{
	[GenerateScriptableCallbacks]
	public partial {GetContainingTypeString(containingType)} MyClass
	{{
		[GenerateValueCallback]
		public ScriptableBool value;
	}}
}}";

		string result = /*lang=cs*/$@"// <auto-generated/>
#nullable enable
namespace My.Namespace
{{
	partial {GetContainingTypeString(containingType)} MyClass
	{{
        <SUBSCRIBED_MASK_SUMMARY>
#if UNITY_EDITOR
		[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
		private enum SubscribedCallbacksMask : byte
        {{
            None = 0,
            valueChanged = 1 << 0
        }}

        <SUBSCRIBED_FIELD_SUMMARY>
#if UNITY_EDITOR
		[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
		private SubscribedCallbacksMask subscribedCallbacks{GetSubscribedMaskDefaultValue(containingType)};

        <SUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
		[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
		[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
		{GetMethodAccessor(containingType)} void SubscribeToAllScriptableCallbacks()
		{{
			if ((subscribedCallbacks & SubscribedCallbacksMask.valueChanged) == 0)
			{{
                value.OnValueChanged += OnValueChanged;
				subscribedCallbacks |= SubscribedCallbacksMask.valueChanged;
			}}
		}}

        <UNSUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
		[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
		[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
		{GetMethodAccessor(containingType)} void UnsubscribeFromAllScriptableCallbacks()
		{{
			if ((subscribedCallbacks & SubscribedCallbacksMask.valueChanged) != 0)
			{{
                value.OnValueChanged -= OnValueChanged;
				subscribedCallbacks &= ~SubscribedCallbacksMask.valueChanged;
			}}
		}}

        {GetCallbackMethodDescription("value", 2, CallbackType.Value, CallbackFlags.PostInvoke)}
		private partial void OnValueChanged(bool oldValue, bool newValue);
	}}
}}";

		AssertGeneratedOutput<ScriptableCallbackGenerator>(source, "My.Namespace.MyClass.g.cs", result);
	}

	[Test]
	public void Value_Field_Arguments_EmitsArgument([ValueSource(nameof(valueArguments))] string argument, [Values] ContainingType containingType)
	{
		string source = /*lang=cs*/$@"using System;
using Hertzole.ScriptableValues;

namespace My.Namespace
{{
	[GenerateScriptableCallbacks]
	public partial {GetContainingTypeString(containingType)} MyClass
	{{
		[GenerateValueCallback({argument})]
		public ScriptableBool value;
	}}
}}";

		string changeSuffix = GetChangeSuffix(argument);
		CallbackFlags flags = GetCallbackFlags(argument);

		string result = /*lang=cs*/$@"// <auto-generated/>
#nullable enable
namespace My.Namespace
{{
	partial {GetContainingTypeString(containingType)} MyClass
	{{
        <SUBSCRIBED_MASK_SUMMARY>
#if UNITY_EDITOR
		[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
		private enum SubscribedCallbacksMask : byte
        {{
            None = 0,
            value{changeSuffix} = 1 << 0
        }}

        <SUBSCRIBED_FIELD_SUMMARY>
#if UNITY_EDITOR
		[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
		private SubscribedCallbacksMask subscribedCallbacks{GetSubscribedMaskDefaultValue(containingType)};

        <SUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
		[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
		[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
		{GetMethodAccessor(containingType)} void SubscribeToAllScriptableCallbacks()
		{{
			if ((subscribedCallbacks & SubscribedCallbacksMask.value{changeSuffix}) == 0)
			{{
                value.OnValue{changeSuffix} += OnValue{changeSuffix};
				subscribedCallbacks |= SubscribedCallbacksMask.value{changeSuffix};
			}}
		}}

        <UNSUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
		[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
		[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
		{GetMethodAccessor(containingType)} void UnsubscribeFromAllScriptableCallbacks()
		{{
			if ((subscribedCallbacks & SubscribedCallbacksMask.value{changeSuffix}) != 0)
			{{
                value.OnValue{changeSuffix} -= OnValue{changeSuffix};
				subscribedCallbacks &= ~SubscribedCallbacksMask.value{changeSuffix};
			}}
		}}

        {GetCallbackMethodDescription("value", 2, CallbackType.Value, flags)}
		private partial void OnValue{changeSuffix}(bool oldValue, bool newValue);
	}}
}}";

		AssertGeneratedOutput<ScriptableCallbackGenerator>(source, "My.Namespace.MyClass.g.cs", result);
	}

	[Test]
	public void Value_Property_NoArguments_EmitsChanged([Values] ContainingType containingType)
	{
		string source = /*lang=cs*/$@"using System;
using Hertzole.ScriptableValues;

namespace My.Namespace
{{
	[GenerateScriptableCallbacks]
	public partial {GetContainingTypeString(containingType)} MyClass
	{{
		[GenerateValueCallback]
		public ScriptableBool Value {{ get; set; }}
	}}
}}";

		string result = /*lang=cs*/$@"// <auto-generated/>
#nullable enable
namespace My.Namespace
{{
	partial {GetContainingTypeString(containingType)} MyClass
	{{
        <SUBSCRIBED_MASK_SUMMARY>
#if UNITY_EDITOR
		[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
		private enum SubscribedCallbacksMask : byte
        {{
            None = 0,
            ValueChanged = 1 << 0
        }}

        <SUBSCRIBED_FIELD_SUMMARY>
#if UNITY_EDITOR
		[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
		private SubscribedCallbacksMask subscribedCallbacks{GetSubscribedMaskDefaultValue(containingType)};

        <SUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
		[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
		[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
		{GetMethodAccessor(containingType)} void SubscribeToAllScriptableCallbacks()
		{{
			if ((subscribedCallbacks & SubscribedCallbacksMask.ValueChanged) == 0)
			{{
				Value.OnValueChanged += OnValueChanged;
				subscribedCallbacks |= SubscribedCallbacksMask.ValueChanged;
			}}
		}}

        <UNSUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
		[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
		[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
		{GetMethodAccessor(containingType)} void UnsubscribeFromAllScriptableCallbacks()
		{{
			if ((subscribedCallbacks & SubscribedCallbacksMask.ValueChanged) != 0)
			{{
				Value.OnValueChanged -= OnValueChanged;
				subscribedCallbacks &= ~SubscribedCallbacksMask.ValueChanged;
			}}
		}}

        {GetCallbackMethodDescription("Value", 2, CallbackType.Value, CallbackFlags.PostInvoke)}
		private partial void OnValueChanged(bool oldValue, bool newValue);
	}}
}}";

		AssertGeneratedOutput<ScriptableCallbackGenerator>(source, "My.Namespace.MyClass.g.cs", result);
	}

	[Test]
	public void Value_Property_Arguments_EmitsArgument([ValueSource(nameof(valueArguments))] string argument, [Values] ContainingType containingType)
	{
		string source = /*lang=cs*/$@"using System;
using Hertzole.ScriptableValues;

namespace My.Namespace
{{
	[GenerateScriptableCallbacks]
	public partial {GetContainingTypeString(containingType)} MyClass
	{{
		[GenerateValueCallback({argument})]
		public ScriptableBool Value {{ get; set; }}
	}}
}}";

		string changeSuffix = GetChangeSuffix(argument);
		CallbackFlags flags = GetCallbackFlags(argument);

		string result = /*lang=cs*/$@"// <auto-generated/>
#nullable enable
namespace My.Namespace
{{
	partial {GetContainingTypeString(containingType)} MyClass
	{{
        <SUBSCRIBED_MASK_SUMMARY>
#if UNITY_EDITOR
		[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
		private enum SubscribedCallbacksMask : byte
        {{
            None = 0,
            Value{changeSuffix} = 1 << 0
        }}

        <SUBSCRIBED_FIELD_SUMMARY>
#if UNITY_EDITOR
		[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
		private SubscribedCallbacksMask subscribedCallbacks{GetSubscribedMaskDefaultValue(containingType)};

        <SUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
		[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
		[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
		{GetMethodAccessor(containingType)} void SubscribeToAllScriptableCallbacks()
		{{
			if ((subscribedCallbacks & SubscribedCallbacksMask.Value{changeSuffix}) == 0)
			{{
				Value.OnValue{changeSuffix} += OnValue{changeSuffix};
				subscribedCallbacks |= SubscribedCallbacksMask.Value{changeSuffix};
			}}
		}}

        <UNSUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
		[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
		[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
		{GetMethodAccessor(containingType)} void UnsubscribeFromAllScriptableCallbacks()
		{{
			if ((subscribedCallbacks & SubscribedCallbacksMask.Value{changeSuffix}) != 0)
			{{
				Value.OnValue{changeSuffix} -= OnValue{changeSuffix};
				subscribedCallbacks &= ~SubscribedCallbacksMask.Value{changeSuffix};
			}}
		}}

        {GetCallbackMethodDescription("Value", 2, CallbackType.Value, flags)}
		private partial void OnValue{changeSuffix}(bool oldValue, bool newValue);
	}}
}}";

		AssertGeneratedOutput<ScriptableCallbackGenerator>(source, "My.Namespace.MyClass.g.cs", result);
	}

	[Test]
	public void Value_Field_NoNamespace_NoArguments_EmitsChanged([Values] ContainingType containingType)
	{
		string source = /*lang=cs*/$@"using System;
using Hertzole.ScriptableValues;

[GenerateScriptableCallbacks]
public partial {GetContainingTypeString(containingType)} MyClass
{{
	[GenerateValueCallback]
	public ScriptableBool value;
}}";

		string result = /*lang=cs*/$@"// <auto-generated/>
#nullable enable
partial {GetContainingTypeString(containingType)} MyClass
{{
    <SUBSCRIBED_MASK_SUMMARY>
#if UNITY_EDITOR
	[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
	private enum SubscribedCallbacksMask : byte
    {{
        None = 0,
        valueChanged = 1 << 0
    }}

    <SUBSCRIBED_FIELD_SUMMARY>
#if UNITY_EDITOR
	[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
	private SubscribedCallbacksMask subscribedCallbacks{GetSubscribedMaskDefaultValue(containingType)};

    <SUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
	[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
	[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
	{GetMethodAccessor(containingType)} void SubscribeToAllScriptableCallbacks()
	{{
		if ((subscribedCallbacks & SubscribedCallbacksMask.valueChanged) == 0)
		{{
			value.OnValueChanged += OnValueChanged;
			subscribedCallbacks |= SubscribedCallbacksMask.valueChanged;
		}}
	}}

    <UNSUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
	[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
	[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
	{GetMethodAccessor(containingType)} void UnsubscribeFromAllScriptableCallbacks()
	{{
		if ((subscribedCallbacks & SubscribedCallbacksMask.valueChanged) != 0)
		{{
			value.OnValueChanged -= OnValueChanged;
			subscribedCallbacks &= ~SubscribedCallbacksMask.valueChanged;
		}}
	}}

    {GetCallbackMethodDescription("value", 1, CallbackType.Value, CallbackFlags.PostInvoke)}
	private partial void OnValueChanged(bool oldValue, bool newValue);
}}";

		AssertGeneratedOutput<ScriptableCallbackGenerator>(source, "MyClass.g.cs", result);
	}

	[Test]
	public void Value_Field_NoNamespace_Arguments_EmitsArgument([ValueSource(nameof(valueArguments))] string argument, [Values] ContainingType containingType)
	{
		string source = /*lang=cs*/$@"using System;
using Hertzole.ScriptableValues;

[GenerateScriptableCallbacks]
public partial {GetContainingTypeString(containingType)} MyClass
{{
	[GenerateValueCallback({argument})]
	public ScriptableBool value;
}}";

		string changeSuffix = GetChangeSuffix(argument);
		CallbackFlags flags = GetCallbackFlags(argument);

		string result = /*lang=cs*/$@"// <auto-generated/>
#nullable enable
partial {GetContainingTypeString(containingType)} MyClass
{{
    <SUBSCRIBED_MASK_SUMMARY>
#if UNITY_EDITOR
	[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
	private enum SubscribedCallbacksMask : byte
    {{
        None = 0,
        value{changeSuffix} = 1 << 0
    }}

    <SUBSCRIBED_FIELD_SUMMARY>
#if UNITY_EDITOR
	[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
	private SubscribedCallbacksMask subscribedCallbacks{GetSubscribedMaskDefaultValue(containingType)};

    <SUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
	[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
	[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
	{GetMethodAccessor(containingType)} void SubscribeToAllScriptableCallbacks()
	{{
		if ((subscribedCallbacks & SubscribedCallbacksMask.value{changeSuffix}) == 0)
		{{
			value.OnValue{changeSuffix} += OnValue{changeSuffix};
			subscribedCallbacks |= SubscribedCallbacksMask.value{changeSuffix};
		}}
	}}

    <UNSUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
	[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
	[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
	{GetMethodAccessor(containingType)} void UnsubscribeFromAllScriptableCallbacks()
	{{
		if ((subscribedCallbacks & SubscribedCallbacksMask.value{changeSuffix}) != 0)
		{{
			value.OnValue{changeSuffix} -= OnValue{changeSuffix};
			subscribedCallbacks &= ~SubscribedCallbacksMask.value{changeSuffix};
		}}
	}}

    {GetCallbackMethodDescription("value", 1, CallbackType.Value, flags)}
	private partial void OnValue{changeSuffix}(bool oldValue, bool newValue);
}}";

		AssertGeneratedOutput<ScriptableCallbackGenerator>(source, "MyClass.g.cs", result);
	}

	[Test]
	public void Value_Property_NoNamespace_NoArguments_EmitsChanged([Values] ContainingType containingType)
	{
		string source = /*lang=cs*/$@"using System;
using Hertzole.ScriptableValues;

[GenerateScriptableCallbacks]
public partial {GetContainingTypeString(containingType)} MyClass
{{
	[GenerateValueCallback]
	public ScriptableBool Value {{ get; set; }}
}}";

		string result = /*lang=cs*/$@"// <auto-generated/>
#nullable enable
partial {GetContainingTypeString(containingType)} MyClass
{{
    <SUBSCRIBED_MASK_SUMMARY>
#if UNITY_EDITOR
	[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
	private enum SubscribedCallbacksMask : byte
    {{
        None = 0,
        ValueChanged = 1 << 0
    }}

    <SUBSCRIBED_FIELD_SUMMARY>
#if UNITY_EDITOR
	[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
	private SubscribedCallbacksMask subscribedCallbacks{GetSubscribedMaskDefaultValue(containingType)};

    <SUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
	[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
	[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
	{GetMethodAccessor(containingType)} void SubscribeToAllScriptableCallbacks()
	{{
		if ((subscribedCallbacks & SubscribedCallbacksMask.ValueChanged) == 0)
		{{
			Value.OnValueChanged += OnValueChanged;
			subscribedCallbacks |= SubscribedCallbacksMask.ValueChanged;
		}}
	}}

    <UNSUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
	[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
	[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
	{GetMethodAccessor(containingType)} void UnsubscribeFromAllScriptableCallbacks()
	{{
		if ((subscribedCallbacks & SubscribedCallbacksMask.ValueChanged) != 0)
		{{
            Value.OnValueChanged -= OnValueChanged;
			subscribedCallbacks &= ~SubscribedCallbacksMask.ValueChanged;
		}}
	}}

    {GetCallbackMethodDescription("Value", 1, CallbackType.Value, CallbackFlags.PostInvoke)}
	private partial void OnValueChanged(bool oldValue, bool newValue);
}}";

		AssertGeneratedOutput<ScriptableCallbackGenerator>(source, "MyClass.g.cs", result);
	}

	[Test]
	public void Value_Property_NoNamespace_Arguments_EmitsArgument([ValueSource(nameof(valueArguments))] string argument,
		[Values] ContainingType containingType)
	{
		string source = /*lang=cs*/$@"using System;
using Hertzole.ScriptableValues;

[GenerateScriptableCallbacks]
public partial {GetContainingTypeString(containingType)} MyClass
{{
	[GenerateValueCallback({argument})]
	public ScriptableBool Value {{ get; set; }}
}}";

		string changeSuffix = GetChangeSuffix(argument);
		CallbackFlags flags = GetCallbackFlags(argument);

		string result = /*lang=cs*/$@"// <auto-generated/>
#nullable enable
partial {GetContainingTypeString(containingType)} MyClass
{{
    <SUBSCRIBED_MASK_SUMMARY>
#if UNITY_EDITOR
	[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
	private enum SubscribedCallbacksMask : byte
    {{
        None = 0,
        Value{changeSuffix} = 1 << 0
    }}

    <SUBSCRIBED_FIELD_SUMMARY>
#if UNITY_EDITOR
	[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
	private SubscribedCallbacksMask subscribedCallbacks{GetSubscribedMaskDefaultValue(containingType)};

    <SUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
	[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
	[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
	{GetMethodAccessor(containingType)} void SubscribeToAllScriptableCallbacks()
	{{
		if ((subscribedCallbacks & SubscribedCallbacksMask.Value{changeSuffix}) == 0)
		{{
			Value.OnValue{changeSuffix} += OnValue{changeSuffix};
			subscribedCallbacks |= SubscribedCallbacksMask.Value{changeSuffix};
		}}
	}}

    <UNSUBSCRIBE_TO_ALL_SUMMARY>
#if UNITY_EDITOR
	[global::System.CodeDom.Compiler.GeneratedCode(""<GENERATOR_NAME>"", ""<ASSEMBLY_VERSION>"")]
#endif // UNITY_EDITOR
#if UNITY_INCLUDE_TESTS
	[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif // UNITY_INCLUDE_TESTS
	{GetMethodAccessor(containingType)} void UnsubscribeFromAllScriptableCallbacks()
	{{
		if ((subscribedCallbacks & SubscribedCallbacksMask.Value{changeSuffix}) != 0)
		{{
            Value.OnValue{changeSuffix} -= OnValue{changeSuffix};
			subscribedCallbacks &= ~SubscribedCallbacksMask.Value{changeSuffix};
		}}
	}}

    {GetCallbackMethodDescription("Value", 1, CallbackType.Value, flags)}
	private partial void OnValue{changeSuffix}(bool oldValue, bool newValue);
}}";

		AssertGeneratedOutput<ScriptableCallbackGenerator>(source, "MyClass.g.cs", result);
	}

	private static string GetChangeSuffix(string argument)
	{
		return argument == valueArguments[0] ? "Changing" : "Changed";
	}

	private static CallbackFlags GetCallbackFlags(string argument)
	{
		CallbackFlags flags = CallbackFlags.None;
		if (argument == valueArguments[0])
		{
			flags |= CallbackFlags.PreInvoke;
		}
		else if (argument == valueArguments[1])
		{
			flags |= CallbackFlags.PostInvoke;
		}

		return flags;
	}

	private static string GetCacheFieldDescription(string name, CallbackType callbackType, CallbackFlags flags = CallbackFlags.None)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("/// <summary>Cached callback for when <see cref=\"");
		sb.Append(name);
		sb.Append("\" /> is ");
		switch (callbackType)
		{
			case CallbackType.Collection:
			case CallbackType.Pool:
			case CallbackType.Value:
				if ((flags & CallbackFlags.PreInvoke) != 0)
				{
					sb.Append("changing");
				}
				else
				{
					sb.Append("changed");
				}

				break;
			case CallbackType.Event:
				sb.Append("invoked");
				break;
			default:
				throw new ArgumentOutOfRangeException(nameof(callbackType), callbackType, null);
		}

		sb.Append(".</summary>");

		return sb.ToString();
	}

	private static string GetCallbackMethodDescription(string name, int indent, CallbackType callbackType, CallbackFlags flags = CallbackFlags.None)
	{
		StringBuilder sb = new StringBuilder();
		// First line never indents
		sb.AppendLine(DocumentationHelper.GetMethodCallbackDescription(name, in callbackType, in flags).ToString());
		sb.Append('\t', indent);
		switch (callbackType)
		{
			case CallbackType.Value:
				sb.Append("/// <param name=\"oldValue\">");
				sb.Append(DocumentationHelper.GetOldValueDescription(in flags));
				sb.AppendLine("</param>");
				sb.Append('\t', indent);
				sb.Append("/// <param name=\"newValue\">");
				sb.Append(DocumentationHelper.GetNewValueDescription(in flags));
				sb.Append("</param>");
				break;
			case CallbackType.Event:
				break;
			case CallbackType.Collection:
				break;
			case CallbackType.Pool:
				break;
			default:
				throw new ArgumentOutOfRangeException(nameof(callbackType), callbackType, null);
		}

		return sb.ToString();
	}

	public enum ContainingType
	{
		Class = 0,
		Struct = 1
	}

	private static string GetContainingTypeString(ContainingType type)
	{
		switch (type)
		{
			case ContainingType.Class:
				return "class";
			case ContainingType.Struct:
				return "struct";
			default:
				throw new ArgumentOutOfRangeException(nameof(type), type, null);
		}
	}

	private static string GetSubscribedMaskDefaultValue(ContainingType type)
	{
		switch (type)
		{
			case ContainingType.Class:
				return " = SubscribedCallbacksMask.None";
			default:
				return string.Empty;
		}
	}

	private static string GetMethodAccessor(ContainingType type, string defaultValue = "protected virtual")
	{
		switch (type)
		{
			case ContainingType.Struct:
				return "private";
			default:
				return defaultValue;
		}
	}
}